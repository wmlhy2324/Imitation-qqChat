# Easy Chat 消息处理流程详解

## 📋 概述

本文档详细描述了Easy Chat系统中从用户发送消息到接收者收到消息的完整流程，包括WebSocket连接处理、消息队列处理、以及两者之间的关系。

## 🏗️ 系统架构

### 核心组件
- **WebSocket服务器** (`apps/im/ws`): 处理实时连接和消息分发
- **Task MQ服务** (`apps/task/mq`): 消息队列处理和持久化
- **Kafka**: 消息队列中间件
- **MongoDB**: 聊天记录存储
- **Redis**: 服务发现和缓存

### 两种WebSocket连接
1. **用户连接**: 浏览器/移动端 ↔ WebSocket服务器
2. **系统连接**: Task MQ服务 ↔ WebSocket服务器（作为客户端）

## 🚀 系统初始化阶段

### 1.1 WebSocket服务器启动
```go
// apps/im/ws/im.go
func main() {
    srv := websocket.NewServer(c.ListenOn, opts...)
    srv.Start()  // 触发server.go中的Start()函数
}

// apps/im/ws/websocket/server.go  
func (s *Server) Start() {
    http.HandleFunc(s.patten, s.ServerWs)  // 注册路由 "/ws"
    http.ListenAndServe(s.addr, nil)      // 监听 :10090
}
```

**触发时机**: 服务器启动时，注册WebSocket路由并开始监听端口

### 1.2 Task MQ服务启动
```go
// apps/task/mq/task.go
func main() {
    Run(c)  // 启动Task MQ服务
}

// apps/task/mq/internal/svc/servicecontext.go
func NewServiceContext(c config.Config) *ServiceContext {
    // Task MQ 作为 WebSocket 客户端连接到 WebSocket 服务器
    svc.WsClient = websocket.NewClient("127.0.0.1:10090",
        websocket.WithClientHeader(header),
        websocket.WithClientDiscover(redisDiscover),
    )
}
```

**触发时机**: Task MQ服务启动时，建立到WebSocket服务器的客户端连接

### 1.3 初始状态
```
- WebSocket服务器监听 :10090，等待连接
- Task MQ作为WebSocket客户端，连接到WebSocket服务器
- Kafka等待消息
- MongoDB等待数据写入
```

## 🔌 用户连接阶段

### 2.1 用户连接触发
```javascript
// 用户浏览器
const websocket = new WebSocket('ws://localhost:10090/ws');
```

### 2.2 WebSocket服务器处理连接
```go
// 触发 ServerWs() 函数
func (s *Server) ServerWs(w http.ResponseWriter, r *http.Request) {
    // 1. 创建WebSocket连接
    conn := NewConn(s, w, r)
    if conn == nil {
        return
    }
    
    // 2. 身份验证
    if !s.authentication.Auth(w, r) {
        conn.Close()
        return
    }
    
    // 3. 记录连接映射
    s.addConn(conn, r)
    
    // 4. 启动连接处理器
    go s.handlerConn(conn)
}
```

### 2.3 连接处理器启动
```go
func (s *Server) handlerConn(conn *Conn) {
    // 1. 设置用户ID
    uids := s.GetUsers(conn)
    conn.Uid = uids[0]
    
    // 2. 服务发现注册（Redis中记录用户-服务器映射）
    s.discover.BoundUser(conn.Uid)  // Redis: userA_id → 127.0.0.1:10090
    
    // 3. 启动消息处理器
    go s.handlerWrite(conn)
    
    // 4. 启动确认处理器（可选）
    if s.isAck(nil) {
        go s.readAck(conn)
    }
    
    // 5. 主循环：等待用户消息
    for {
        _, msg, err := conn.ReadMessage()  // 阻塞等待
        if err != nil {
            s.Close(conn)
            return
        }
        
        // 解析并分发消息
        var message Message
        json.Unmarshal(msg, &message)
        
        if s.isAck(&message) {
            conn.appendMsgMq(&message)
        } else {
            conn.message <- &message  // 发送到处理通道
        }
    }
}
```

### 2.4 消息处理器启动
```go
func (s *Server) handlerWrite(conn *Conn) {
    for {
        select {
        case <-conn.done:
            return  // 连接关闭
            
        case message := <-conn.message:  // 等待消息
            switch message.FrameType {
            case FramePing:
                s.Send(&Message{FrameType: FramePing}, conn)
            case FrameData:
                // 路由分发
                if handler, ok := s.routes[message.Method]; ok {
                    handler(s, conn, message)  // 调用业务处理器
                }
            }
        }
    }
}
```

## 📨 消息发送和处理阶段

### 3.1 用户发送消息
```javascript
// 用户A的浏览器
websocketA.send(JSON.stringify({
    frameType: 0,
    id: 'msg_123',
    method: 'conversation.chat',
    formId: 'userA_id',
    data: {
        chatType: 2,                    // 单聊
        recvId: 'userB_id',
        conversationId: 'userA_id_userB_id',
        msg: { mType: 0, content: 'Hello!' }
    }
}));
```

### 3.2 WebSocket服务器接收消息（同步处理）
```go
// 对于同一条消息，严格按顺序执行：

// 步骤1: handlerConn接收消息
_, msg, err := conn.ReadMessage()         // 接收WebSocket数据
var message Message
json.Unmarshal(msg, &message)           // 解析JSON
conn.message <- &message                // 放入通道

// 步骤2: handlerWrite处理消息  
message := <-conn.message               // 从通道取出
handler(s, conn, message)              // 调用Chat处理器
```

### 3.3 聊天处理器处理
```go
// apps/im/ws/internal/handler/conversation/conersation.go
func Chat(svc *svc.ServiceContext) websocket.HandlerFunc {
    return func(srv *websocket.Server, conn *websocket.Conn, msg *websocket.Message) {
        // 1. 解析消息数据
        var data ws.Chat
        mapstructure.Decode(msg.Data, &data)
        
        // 2. 生成会话ID（如果没有）
        if data.ConversationId == "" {
            switch data.ChatType {
            case constants.SingleChatType:
                data.ConversationId = wuid.CombineId(conn.Uid, data.RecvId)
            case constants.GroupChatType:
                data.ConversationId = data.RecvId
            }
        }
        
        // 3. 推送到Kafka消息队列
        err := svc.MsgChatTransferClient.Push(&mq.MsgChatTransfer{
            ConversationId: data.ConversationId,
            ChatType:       data.ChatType,
            SendId:         conn.Uid,           // userA_id
            RecvId:         data.RecvId,        // userB_id
            SendTime:       time.Now().UnixMilli(),
            MType:          data.Msg.MType,
            Content:        data.Msg.Content,   // "Hello!"
            MsgId:          msg.Id,
        })
        
        if err != nil {
            srv.Send(websocket.NewErrMessage(err), conn)
        }
    }
}
```

## 🔄 消息队列处理阶段

### 4.1 Task MQ消费Kafka消息
```go
// apps/task/mq/internal/handler/msgTransfer/msgChatTrasnfer.go
func (m *MsgChatTransfer) Consume(key, value string) error {
    fmt.Println("key : ", key, " value : ", value)
    
    var (
        data  mq.MsgChatTransfer
        ctx   = context.Background()
        msgId = primitive.NewObjectID()
    )
    
    // 1. 反序列化Kafka消息
    if err := json.Unmarshal([]byte(value), &data); err != nil {
        return err
    }
    
    // 2. 保存聊天记录到MongoDB
    if err := m.addChatLog(ctx, msgId, &data); err != nil {
        return err
    }
    
    // 3. 推送消息给目标用户
    return m.Transfer(ctx, &ws.Push{
        ConversationId: data.ConversationId,
        ChatType:       data.ChatType,
        SendId:         data.SendId,
        RecvId:         data.RecvId,
        RecvIds:        data.RecvIds,
        SendTime:       data.SendTime,
        MType:          data.MType,
        MsgId:          msgId.Hex(),
        Content:        data.Content,
    })
}
```

### 4.2 保存聊天记录
```go
func (m *MsgChatTransfer) addChatLog(ctx context.Context, msgId primitive.ObjectID, data *mq.MsgChatTransfer) error {
    // 构造聊天记录
    chatLog := immodels.ChatLog{
        ID:             msgId,
        ConversationId: data.ConversationId,
        SendId:         data.SendId,
        RecvId:         data.RecvId,
        ChatType:       data.ChatType,
        MsgFrom:        0,
        MsgType:        data.MType,
        MsgContent:     data.Content,
        SendTime:       data.SendTime,
    }
    
    // 设置已读记录（发送者默认已读）
    readRecords := bitmap.NewBitmap(0)
    readRecords.Set(chatLog.SendId)
    chatLog.ReadRecords = readRecords.Export()
    
    // 1. 插入聊天记录到MongoDB
    err := m.svcCtx.ChatLogModel.Insert(ctx, &chatLog)
    if err != nil {
        return err
    }
    
    // 2. 更新会话最新消息
    return m.svcCtx.ConversationModel.UpdateMsg(ctx, &chatLog)
}
```

### 4.3 消息转发处理
```go
// apps/task/mq/internal/handler/msgTransfer/msgTransfer.go
func (m *baseMsgTransfer) Transfer(ctx context.Context, data *ws.Push) error {
    switch data.ChatType {
    case constants.GroupChatType:
        return m.group(ctx, data)      // 群聊处理
    case constants.SingleChatType:
        return m.single(ctx, data)     // 单聊处理
    }
    return nil
}

// 单聊处理
func (m *baseMsgTransfer) single(ctx context.Context, data *ws.Push) error {
    // Task MQ通过WebSocket客户端发送push请求到WebSocket服务器
    return m.svcCtx.WsClient.Send(websocket.Message{
        FrameType: websocket.FrameData,
        Method:    "push",                    // 调用push处理器
        FormId:    constants.SYSTEM_ROOT_UID, // 系统发送
        Data:      data,                      // 消息数据
    })
}

// 群聊处理
func (m *baseMsgTransfer) group(ctx context.Context, data *ws.Push) error {
    // 1. 查询群组所有成员
    users, err := m.svcCtx.Social.GroupUsers(ctx, &socialclient.GroupUsersReq{
        GroupId: data.RecvId,
    })
    if err != nil {
        return err
    }
    
    // 2. 构造接收者列表（排除发送者）
    data.RecvIds = make([]string, 0, len(users.List))
    for _, members := range users.List {
        if members.UserId == data.SendId {
            continue  // 不给自己发送
        }
        data.RecvIds = append(data.RecvIds, members.UserId)
    }
    
    // 3. 批量推送
    return m.svcCtx.WsClient.Send(websocket.Message{
        FrameType: websocket.FrameData,
        Method:    "push",
        FormId:    constants.SYSTEM_ROOT_UID,
        Data:      data,
    })
}
```

## 📱 消息推送阶段

### 5.1 WebSocket服务器处理Push请求
```go
// apps/im/ws/internal/handler/push/push.go
func Push(svc *svc.ServiceContext) websocket.HandlerFunc {
    return func(srv *websocket.Server, conn *websocket.Conn, msg *websocket.Message) {
        var data ws.Push
        if err := mapstructure.Decode(msg.Data, &data); err != nil {
            srv.Send(websocket.NewErrMessage(err))
            return
        }
        
        // 根据聊天类型分发
        switch data.ChatType {
        case constants.SingleChatType:
            single(srv, &data, data.RecvId)  // 推送给单个用户
        case constants.GroupChatType:
            group(srv, &data)                // 推送给群组成员
        }
    }
}
```

### 5.2 单聊消息推送
```go
func single(srv *websocket.Server, data *ws.Push, recvId string) error {
    // 1. 查找目标用户的WebSocket连接
    rconn := srv.GetConn(recvId)  // 获取userB_id的连接
    if rconn == nil {
        // 用户离线，无法推送（可以实现离线消息存储）
        return nil
    }
    
    srv.Infof("push msg %v", data)
    
    // 2. 构造推送消息
    return srv.Send(websocket.NewMessage(data.SendId, &ws.Chat{
        ConversationId: data.ConversationId,
        ChatType:       data.ChatType,
        SendTime:       data.SendTime,
        Msg: ws.Msg{
            ReadRecords: data.ReadRecords,
            MsgId:       data.MsgId,
            MType:       data.MType,
            Content:     data.Content,
        },
    }), rconn)  // 发送给用户B的WebSocket连接
}
```

### 5.3 群聊消息推送
```go
func group(srv *websocket.Server, data *ws.Push) error {
    // 异步推送给所有群成员
    for _, id := range data.RecvIds {
        func(id string) {
            srv.Schedule(func() {        // 异步执行
                single(srv, data, id)    // 调用单聊推送逻辑
            })
        }(id)
    }
    return nil
}
```

## 📱 客户端接收阶段

### 6.1 用户B接收消息
```javascript
// 用户B的浏览器
websocketB.onmessage = function(event) {
    const message = JSON.parse(event.data);
    
    // 接收到的消息格式：
    // {
    //   "frameType": 0,
    //   "formId": "userA_id",          // 发送者ID
    //   "data": {
    //     "conversationId": "userA_id_userB_id",
    //     "chatType": 2,               // 单聊
    //     "sendTime": 1640995200000,
    //     "msg": {
    //       "msgId": "507f1f77bcf86cd799439011",
    //       "mType": 0,                // 文本消息
    //       "content": "Hello!"        // 消息内容
    //     }
    //   }
    // }
    
    if (message.frameType === 0 && message.data.conversationId) {
        const chatData = message.data;
        
        // 1. 更新聊天界面
        addMessageToUI({
            senderId: message.formId,
            content: chatData.msg.content,
            sendTime: chatData.sendTime,
            conversationId: chatData.conversationId
        });
        
        // 2. 更新会话列表
        updateConversationList(chatData.conversationId, {
            lastMessage: chatData.msg.content,
            lastTime: chatData.sendTime
        });
        
        // 3. 播放提示音
        if (currentConversationId !== chatData.conversationId) {
            playNotificationSound();
        }
        
        // 4. 更新未读数量
        updateUnreadCount(chatData.conversationId);
    }
};
```

## 🎯 完整时序图

```
用户A浏览器    WebSocket服务器    Kafka队列    Task MQ服务    MongoDB    Redis    用户B浏览器
     |              |              |           |             |         |           |
 1.  |─连接请求────→  |              |           |             |         |           |
 2.  |              |─建立connA───→  |           |             |         |←─用户映射─  |
 3.  |              |              |           |─连接WS─────→ |         |           |
 4.  |              |              |           |             |         |           |─连接请求→
 5.  |              |              |           |             |         |←─用户映射─  |←─建立connB─
 6.  |              |              |           |             |         |           |
 7.  |─发送消息────→  |              |           |             |         |           |
 8.  |              |─Chat处理────→  |           |             |         |           |
 9.  |              |─推送Kafka───→  |           |             |         |           |
10.  |              |              |←─消费消息── |             |         |           |
11.  |              |              |           |─保存记录───→ |         |           |
12.  |              |              |           |─更新会话───→ |         |           |
13.  |              |←─发送push────  |           |             |         |           |
14.  |              |─push处理────→  |           |             |         |           |
15.  |              |─查找connB───→  |           |             |         |           |
16.  |              |─推送消息──────────────────────────────────────────→ |           |
17.  |              |              |           |             |         |           |←─显示消息─
```

## 🔄 关键触发机制总结

### WebSocket连接处理触发时机
1. **ServerWs()**: 客户端发起WebSocket连接时
2. **handlerConn()**: 连接建立后立即启动
3. **handlerWrite()**: 连接建立后立即启动，等待消息
4. **addConn()**: 身份验证通过后立即执行
5. **Close()**: 连接断开时自动触发

### 消息队列处理触发时机
1. **Chat处理器**: 用户发送聊天消息时
2. **Kafka Push**: Chat处理器执行时
3. **MQ Consume**: Kafka有新消息时
4. **MongoDB Insert**: MQ消费消息时
5. **Push请求**: MQ处理完存储后

### 执行顺序特点
- **同一条消息**: 严格按顺序处理（接收→解析→处理→推送）
- **不同消息**: 可以并发处理（通过goroutine和通道）
- **异步解耦**: 通过Kafka实现发送和接收的异步处理
- **分布式支持**: 通过Redis服务发现支持多服务器部署

## 🎯 性能特点

### 优势
1. **异步处理**: 消息发送后立即返回，不阻塞用户
2. **可靠性**: 消息先保存到MongoDB再推送
3. **可扩展**: 支持多WebSocket服务器集群
4. **顺序保证**: 通过时间戳和队列保证消息顺序

### 注意事项
1. **通道缓冲**: 每个连接的消息通道缓冲区为1，高频消息可能阻塞
2. **离线用户**: 离线用户消息已保存，但需要额外的离线推送机制
3. **网络延迟**: 跨服务器消息转发会增加延迟
4. **故障恢复**: 需要考虑各组件故障时的消息处理机制

---

*本文档描述了Easy Chat系统的完整消息处理流程，涵盖了从用户发送消息到接收者收到消息的每个环节。*
