# Easy-Chat 踩坑指南

## 问题1：好友申请接口返回"数据库繁忙，稍后再尝试"错误

### 问题描述

调用好友申请接口 `POST /api/v1/social/friend/putIn` 时，持续返回错误：

```json
{
    "code": 100003,
    "msg": "数据库繁忙，稍后再尝试",
    "data": null
}
```

### 错误现象

- **错误代码**: 100003 (DB_ERROR)
- **错误信息**: "数据库繁忙，稍后再尝试"
- **频率**: 每次调用都出现
- **影响范围**: 好友申请功能完全不可用

### 排查过程

#### 1. 检查错误代码定义

查看 `pkg/xerr/err_code.go` 和 `pkg/xerr/err_msg.go`：

```go
const (
    SERVER_COMMON_ERROR = 100001
    REQUEST_PARAM_ERROR = 100002
    DB_ERROR            = 100003  // 对应错误码100003
)

var codeText = map[int]string{
    DB_ERROR: "数据库繁忙，稍后再尝试",  // 对应错误信息
}
```

确认这是数据库相关错误。

#### 2. 检查数据库连接状态

```bash
docker-compose ps
```

确认 MySQL、Redis 等基础服务运行正常。

#### 3. 查看服务日志

关键发现在 `logs/social-rpc.log` 中：

```log
{"@timestamp":"2025-09-23T00:55:40.222+08:00","caller":"sqlx/utils.go:147","content":"stmt: insert into `friend_requests` (...) values (..., '57696-07-20 15:44:51 +0800 CST', ...), error: year is not in the range [1, 9999]: 57696","level":"error"}
```

**关键信息**：
- 数据库插入操作失败
- 年份计算结果为 57696，超出数据库支持范围 [1, 9999]
- 传入的时间戳：`reqTime:1758560139891`

### 根本原因

**时间戳转换错误**：

1. **问题代码位置**：
   - `apps/social/rpc/internal/logic/friendputinlogic.go:61`
   - `apps/social/rpc/internal/logic/groupputinlogic.go:73`

2. **错误代码**：
   ```go
   ReqTime: time.Unix(in.ReqTime, 0),  // 错误：将毫秒当作秒处理
   ```

3. **原因分析**：
   - 前端传入的 `reqTime` 是**毫秒级时间戳**：`1758560139891`
   - `time.Unix(timestamp, 0)` 期望的是**秒级时间戳**
   - 将毫秒级时间戳当作秒级处理，导致年份计算为 57696 年
   - MySQL 的 DATETIME 类型只支持年份范围 [1, 9999]

4. **计算验证**：
   ```bash
   # 正确转换（毫秒转秒）
   date -d @$(echo "1758560139891/1000" | bc)
   # 输出：2025年9月22日
   
   # 错误转换（直接当作秒）
   date -d @1758560139891
   # 输出：57696年（超出数据库范围）
   ```

### 解决方案

#### 修复代码

将时间戳转换从 `time.Unix()` 改为 `time.UnixMilli()`：

**修复前**：
```go
ReqTime: time.Unix(in.ReqTime, 0),
```

**修复后**：
```go
ReqTime: time.UnixMilli(in.ReqTime),
```

#### 涉及文件

1. `apps/social/rpc/internal/logic/friendputinlogic.go` (行61)
2. `apps/social/rpc/internal/logic/groupputinlogic.go` (行73)

#### 修复步骤

1. **停止服务**：
   ```bash
   ./stop-local.sh
   ```

2. **修改代码**：
   ```bash
   # 修复好友申请逻辑
   sed -i 's/time\.Unix(in\.ReqTime, 0)/time.UnixMilli(in.ReqTime)/g' apps/social/rpc/internal/logic/friendputinlogic.go
   
   # 修复群申请逻辑  
   sed -i 's/time\.Unix(in\.ReqTime, 0)/time.UnixMilli(in.ReqTime)/g' apps/social/rpc/internal/logic/groupputinlogic.go
   ```

3. **重启服务**：
   ```bash
   ./start-local.sh
   ```

### 验证修复

修复后，同样的请求应该成功：

```bash
curl -X POST http://localhost:3000/api/v1/social/friend/putIn \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "reqUid": "target_user_id", 
    "reqMsg": "申请添加好友",
    "reqTime": 1758560139891
  }'
```

预期返回：
```json
{
    "code": 0,
    "msg": "success", 
    "data": {}
}
```

### 预防措施

#### 1. 代码规范

- **时间戳处理规范**：
  - 前端传递毫秒级时间戳时，后端使用 `time.UnixMilli()`
  - 前端传递秒级时间戳时，后端使用 `time.Unix()`
  - 在接口文档中明确标注时间戳精度

#### 2. 参数验证

在业务逻辑中添加时间戳合理性检查：

```go
func validateTimestamp(timestamp int64) error {
    // 检查时间戳是否在合理范围内
    now := time.Now().Unix()
    if timestamp > now*1000+86400*1000 { // 超过当前时间1天(毫秒)
        return errors.New("时间戳不合理，可能单位错误")
    }
    
    // 转换后的时间是否在数据库支持范围内
    t := time.UnixMilli(timestamp)
    if t.Year() < 1 || t.Year() > 9999 {
        return errors.New("时间戳转换后年份超出数据库支持范围")
    }
    
    return nil
}
```

#### 3. 单元测试

添加时间戳转换的单元测试：

```go
func TestTimestampConversion(t *testing.T) {
    testCases := []struct {
        input    int64
        expected string
    }{
        {1758560139891, "2025-09-22"}, // 毫秒级时间戳
        {1758560139, "2025-09-22"},    // 秒级时间戳  
    }
    
    for _, tc := range testCases {
        result := time.UnixMilli(tc.input)
        if result.Format("2006-01-02") != tc.expected {
            t.Errorf("时间戳转换错误: %d -> %s, 期望: %s", 
                tc.input, result.Format("2006-01-02"), tc.expected)
        }
    }
}
```

#### 4. 错误日志优化

在数据库操作失败时，记录更详细的错误信息：

```go
if err != nil {
    logx.Errorf("数据库操作失败 - SQL: %s, 参数: %+v, 错误: %v", 
        sqlStr, params, err)
    return nil, errors.Wrapf(xerr.NewDBErr(), 
        "insert friendRequest err %v req %v", err, in)
}
```

### 总结

这个问题的核心是**时间戳精度不匹配**导致的数据库约束违反。虽然表面现象是"数据库繁忙"，但实际原因是数据格式错误。

**经验教训**：
1. 不要被错误信息的字面意思误导，要深入日志找到根本原因
2. 时间戳处理需要格外小心，前后端要约定好精度（秒/毫秒）
3. 数据库字段的约束范围要在业务逻辑中提前验证
4. 良好的错误日志是快速定位问题的关键

---

## 其他常见踩坑点

### 1. 并发限制问题

如果遇到"concurrent connections over limit"错误，检查：
- `pkg/interceptor/rpcserver/syncxlimitinterceptor.go` 中的并发限制设置
- 服务启动时的拦截器配置

### 2. 数据库连接池问题

如果出现真正的数据库连接问题，检查：
- MySQL 配置中的连接池大小
- 连接超时设置
- 数据库最大连接数限制

### 3. Redis 连接问题

如果缓存相关功能异常：
- 检查 Redis 服务状态
- 验证 Redis 密码配置
- 确认端口映射正确

---

*最后更新：2025-09-23*
